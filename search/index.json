[{"content":" 最近面試被問到有關 Transaction 的問題時，幾乎答不出來Orz，趕緊查資料來壓壓驚。\n這篇我會從官方文件及網路文章擷取部分內容，試著理解 Postgres 中的 Transaction ，用 Docker 建立 Postgres 來做實驗，試著重現其中幾種狀況，由於我個人理解程度還不夠深，建議去閱讀參考資源的文章會收穫更多喔！\n先來一段官方的介紹，詳細的內容在 PostgreSQL MVCC 簡介。\nPostgreSQL 為開發者們提供了豐富的工具來管理資料的 同時存取。資料的 一致性 在資料庫內部是以 多重資料版本的方式維護（Multiversion Concurrency Control，MVCC），這表示無論目前資料的當下狀態如何，每個 SQL 指令會看見的是資料在一段時間前的 快照 （資料庫的某個版本）。\n而MVCC這個功能大多數資料庫已經實現了，詳細參考 維基百科-多版本並行控制 。\n這次實驗的範圍以 交易隔離(Transaction Isolation) 為主 ，以我個人根據官方手冊提供的解釋及範例來做實驗，若過程中有錯誤認知也請不吝告知！\n小試身手 可以先到 Crunchydata Tutorials - Transactions 去試一遍 postgres 中的 transaction 行為，照著做之外也可以去試著理解教學的重點喔！\nSQL Transaction 在實驗前先來複習一下 資料庫交易行為(Transaction) 的特性，以下節錄自 SQL 大小事 - Po-Ching **Liu。**\n在資料庫中，交易(事務) 意旨由各種 資料庫操作(select、update、insert等) 所組成的邏輯過程。\n在資料庫中為保證其交易是正確且可靠的，必需滿足以下 四個特性 ：\n原子性(Atomicity)\n在資料庫的每一筆交易中只有兩種可能發生，第一種是全部完全(commit)，第二種是全部不完成(rollback)，不會因為某個環節出錯，而終止在那個環節，在出錯之後會恢復至交易之前的狀態，如同還沒執行此筆交易。 一致性(Consistency)\n在交易中會產生資料或者驗證狀態，然而當錯誤發生，所有已更改的資料或狀態將會恢復至交易之前。 隔離性(Isolation)\n資料庫允許多筆交易同時進行，交易進行時未完成的交易資料並不會被其他交易使用，直到此筆交易完成。 持續性(Durability)\n交易完成後對資料的修改是永久性的，資料不會因為系統重啟或錯誤而改變。 什麼是 交易隔離(Transaction Isolation) ? 以下節錄自 PostgreSQL 交易隔離 及 資料庫 Transaction \u0026amp; Lock 筆記。\n在不同等級中發生 競爭條件(Race condition) 是：\nDirty write (髒寫)\ntransaction 尚未 commit 的情況下，其值被另一個 transaction 給覆寫。 Dirty read (髒讀)\ntransaction 讀取的資料是由尚未 commit 的 concurrency transaction 寫入的。 Non-repeatable read (無法重複的讀取)\n又可稱作 讀取偏差(read skew) ，transaction 重新讀取它之前讀過的資料，但是卻發現資料被其他 transaction 修改（在最初讀取之後commit）了。 Phantom read (幻讀)\n又可稱作 寫入偏差(wirte skew) ，transaction 重新執行查詢，得到滿足搜尋條件的資料集，但卻發現得到的資料集因為其他最近剛 commit 的 transaction 而變更了。 Serialization anomaly (序列化異常)\n在成功提交一群 transactions 後，結果與以所有可能的順序依序執行交易的結果都不一致。 SQL 標準中定義了四個等級的交易隔離 :\nRead uncommitted : 代表 transaction 可以讀到別的 transaction 尚未 commit 的資料，在這個等級中 race condition 三個問題都沒有解決。 Read committed : 代表 transaction 只能讀到別的 transaction 已經 commit 的資料，沒有 commit 的話就不會讀到，在這個等級解決了 Dirty read 的問題，為 Postgres 預設等級。 Repeatable read : 代表每次 transaction 要讀取特定欄位的資料時，只要 query 條件相同，讀取到的資料內容就會相同，在這個等級解決了 Non-repeatable read 的問題，為 MYSQL InnoDB 預設等級 。 Serializable : 代表在多個 transaction 同時執行時，只要 transaction 的順序相同時，得到的結果一定相同。比如說 Transaction A 先執行了接下來再執行 Transaction B，在同樣的條件下，每次執行都會得到一樣的結果，在這個等級下連同 Phantom read 也會一併被解決。 交易隔離等級與競爭條件 隔離等級 Dirty write Dirty read Non-repeatable read Phantom read Serialization anomaly Read uncommitted 不可能 允許，但PG中不會 可能 可能 可能 Read committed 不可能 不可能 可能 可能 可能 Repeatable read 不可能 不可能 不可能 允許，但PG中不會 可能 Serializable 不可能 不可能 不可能 不可能 不可能 資料工程師修煉之路 Part II IThome 鐵人賽中的系列文章，有附圖而且解釋的更詳細，非常推薦去閱讀！\n實驗環境 Mac M1 Docker 20.10.17 Docker Compose 2.2.3 Docker Image: postgres:14-alpine 模擬 race condition 發生 由於在 RDBMS 中的 transaction 不允許 dirty write(髒寫) 的狀況發生，有關其狀況可以參考其他文章解釋，而 serialization anomaly(序列化異常) 我還不清楚如何重現🥲，dirty read(髒讀) 在 postgres 中也被限制，這邊就先試著重現一種 race condition 的狀況，並觀察修改 isolation 等級前後的結果。\nNon - Repeatable Read(Read skew) 模擬在 Read committed 等級底下會發生的問題。\n參考以下情境進行實驗：\nAlice 擁有兩個銀行帳戶，各有 500 元在帳戶中，共有 1000 元 有個轉帳作業發起 transaction 從 Account 1 轉帳至 Account 2 Alice 發起的 transaction 在轉帳前查了 Account 1 ，在轉帳後查了 Account 2，得到總額 900元的資訊，發現總金額少了 100 元，但帳戶中總額確實為 1000 元 Alice 需要再次查詢才可取得正確的結果 這個情境下符合 Read committed 等級中允許讀取已 committed 的資料，但沒有保證在同一個 transaction 下，所取得的資料都是同一份。\nGitHub repo： https://github.com/zeroLR/first-try-transaction-isolation\n建立資料夾\n1 2 3 mkdir -p first-try-transaction-isolation/non-repeatable-read cd first-try-transaction-isolation/non-repeatable-read touch docker-compose.yml docker-compose 配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3.1\u0026#39; services: db: container_name: pg image: postgres:14-alpine restart: always environment: POSTGRES_DB: postgres POSTGRES_USER: postgres POSTGRES_PASSWORD: postgres working_dir: /usr/src # 直接把現在資料夾內容映射至建立的container中，copy所需檔案進去比較好，這邊僅為了方便操作 volumes: - .:/usr/src 啟動 container 的順序不影響映射到 container 中的檔案，這邊就先啟動\n1 sudo docker-compose up -d 建立 sql 檔\ninitdb.sql\n1 2 3 4 5 6 7 8 BEGIN; DROP TABLE IF EXISTS accounts; CREATE TABLE accounts(id SERIAL PRIMARY KEY, balance INT); INSERT INTO accounts(balance) VALUES(500); INSERT INTO accounts(balance) VALUES(500); COMMIT; alice.sql(註解那行表示設定此transaction的隔離等級)\n1 2 3 4 5 6 7 8 9 BEGIN; -- SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; SELECT balance FROM accounts WHERE id = 1; SELECT balance FROM accounts WHERE id = 2; COMMIT; transfer.sql\n1 2 3 4 5 6 7 8 BEGIN; UPDATE accounts SET balance = balance + 100 WHERE id = 1; UPDATE accounts SET balance = balance - 100 WHERE id = 2; COMMIT; 建立 shell script\nlab.sh\n1 2 3 4 5 6 7 8 9 10 11 #!/bin/sh path=/usr/src/non-repeatable-read # 執行 initdb 中的 query 初始化實驗環境 psql -U postgres -f $path/initdb.sql --out log.txt # 將兩個執行 transaction 放到背景並發執行 psql -U postgres -f $path/alice.sql \u0026amp; psql -U postgres -f $path/transfer.sql \u0026amp; start.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #!/bin/sh RED=\u0026#39;\\033[0;31m\u0026#39; BLUE=\u0026#39;\\033[0;34m\u0026#39; GREEN=\u0026#39;\\033[0;32m\u0026#39; NC=\u0026#39;\\033[0m\u0026#39; path=/usr/src/non-repeatable-read cycle=300 # 執行次數 snapshotAfterTransaction=0 # 另一筆 transaction commit 前取得的快照計數 snapshotBeforeTransaction=0 # 另一筆 transaction commit 後取得的快照計數 snapshotNonRepeatable=0 # 另一筆 transaction 中取到不同快照計數 for i in $(seq 1 $cycle); do # 執行 lab.sh 中的指令，並過濾出有400、500、600的結果 output=$(sh $path/lab.sh | grep -E \u0026#39;400|500|600\u0026#39;) # 儲存各種狀況結果 ## 兩筆資料皆是另一筆 transaction commit 後的快照 snapshot1=$(echo $output | grep \u0026#39;600 400\u0026#39;) ## 兩筆資料皆是另一筆 transaction begin 前的快照 snapshot2=$(echo $output | grep \u0026#39;500 500\u0026#39;) ## 第一筆資料為另一筆 transaction begin 前的快照，第二筆則為 transaction commit 後的快照 snapshot3=$(echo $output | grep \u0026#39;500 400\u0026#39;) if [ ! -z \u0026#34;$snapshot1\u0026#34; ] then let snapshotAfterTransaction++ echo -e \u0026#34;${GREEN}$snapshot1${NC}\u0026#34; fi if [ ! -z \u0026#34;$snapshot2\u0026#34; ] then let snapshotBeforeTransaction++ echo -e \u0026#34;${BLUE}$snapshot2${NC}\u0026#34; fi if [ ! -z \u0026#34;$snapshot3\u0026#34; ] then let snapshotNonRepeatable++ echo -e \u0026#34;${RED}$snapshot3${NC}\u0026#34; fi # 三種狀況結果統計 if [ $i -eq $cycle ] then echo -e \u0026#34;${GREEN}AfterTransaction: ${snapshotAfterTransaction}\\n${BLUE}BeforeTransaction: ${snapshotBeforeTransaction}\\n${RED}Non-repeatable: $snapshotNonRepeatable${NC}\u0026#34; fi done 檔案準備好之後，執行 start.sh 即可開始實驗，使用 time -p 可以得知執行時間\n1 time -p sh start.sh 實驗結果 Read committed (postgres 預設等級) 使用預設隔離等級，300次實驗中有8次得到有問題的結果。\nRepeatable Read 設定 SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 後，300次實驗中無發生不正確的結果，相對的取得另一交易後的資料次數較少。\n總結 如果再將實驗次數拉高或許結果會更準確，不過我也不是很確定這個做法有沒有其他問題，只是覺得能夠重現同樣的問題並且去解決它，是一件蠻有成就的事，這次只有寫 Non-repeatable Read(read skew) 的實驗，之後有空再試試重現 Phantom Read(write skew)。 參考資料 維基百科-多版本並行控制 Crunchydata Tutorials - Transactions PostgreSQL 14 transaction-iso PostgreSQL MVCC 簡介 PostgreSQL 交易隔離 SQL 大小事 資料庫 Transaction \u0026amp; Lock 筆記 資料工程師修煉之路 Part II ","date":"2022-10-22T17:57:01.549Z","image":"https://blog.zerolr.net/assets/images/pg.jpeg","permalink":"https://blog.zerolr.net/p/2022/10/22/first-try-transaction-isolation/","title":"【PostgreSQL】初探 Transaction Isolation"},{"content":"這篇紀錄在 docker busybox 中使用 shell script 同時執行多個指令，比較使用 \u0026amp; 將命令帶到背景執行與在前景執行時的狀況，如理解有誤也歡迎糾正。\n程式碼放在 github: https://github.com/zeroLR/concurrency-on-sh\n實驗環境 Mac M1 Docker 20.10.17 Docker Compose 2.2.3 Docker Image: busybox:latest 建立實驗環境 建立資料夾 。\n1 2 mkdir concurrency-on-sh cd concurrency-on-sh 執行以下指令產生本次實驗檔案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 cat \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; \u0026gt;\u0026gt; foreground.sh #!/bin/sh sleep 3 ; echo \u0026#34;First job has been completed.\u0026#34; sleep 9 ; echo \u0026#34;Next job has been completed.\u0026#34; sleep 6 ; echo \u0026#34;All jobs have been completed.\u0026#34; EOF cat \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; \u0026gt;\u0026gt; background.sh #!/bin/sh sleep 3 \u0026amp; echo $! sleep 9 \u0026amp; echo $! sleep 6 \u0026amp; echo $! wait -n echo \u0026#34;First job has been completed.\u0026#34; wait -n echo \u0026#34;Next job has been completed.\u0026#34; wait echo \u0026#34;All jobs have been completed.\u0026#34; EOF cat \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; \u0026gt;\u0026gt; zombie.sh #!/bin/sh for i in `seq 1 10` do sleep 10 \u0026amp; echo $! done wait EOF 使用 docker 或 docker-compose 啟動 container，將實驗檔案 mount 至 container 中。\n1 2 # docker command sudo docker run -dti --restart always --workdir /home --mount type=bind,source=\u0026#34;$(pwd)/\u0026#34;,target=/home --name busybox busybox ash 1 2 3 4 5 6 7 8 9 10 11 12 13 # concurrency-on-sh/docker-compose.yml version: \u0026#34;3.1\u0026#34; services: busybox: container_name: busybox image: busybox:latest stdin_open: true tty: true restart: always working_dir: /home command: ash volumes: - .:/home 1 2 # docker-compose sudo docker-compose up -d 開啟兩個 shell ，都使用 docker exec 進入 container 的 shell 中。\n1 sudo docker exec -ti busybox busybox ash 其中一個 shell 執行 top 開啟系統監視(按 1 可以顯示各個 CPU 資源)，待會實驗時方便觀察 process 的增減過程。\n前景執行 一般在 shell 中未加上 \u0026amp; 的命令就會放在前景處理，且一次只會處理一個 process，使用 shell script 執行多個命令時，也是一次只產生一個 process：\n1 time -p sh foreground.sh 使用 time -p 執行命令，會將 time -p 後的命令作為其子程序執行，再由這個子程序作為父程序執行 shell script ，產生出新的程序(有點繞口 XD)，待所有子程序都執行完畢後，回傳從程序執行到結束所經過的時間。\n第一個子程序等待 3 秒：\n開始第二個子程序等待 9 秒，回傳第一個子程序結束後執行的訊息：\n開始第三個子程序等待 6 秒，回傳第二個子程序結束後執行的訊息：\n所有程序結束，回傳訊息與執行時間，總共花費 3+6+9 = 18 秒：\n背景執行 現在將前景執行的命令放到背景執行，並回傳子程序 PID，使用 wait 等待程序結束：\n1 time -p sh background.sh 同時產生三個子程序，放在背景由 Linux 去做並發或平行處理，其中 CPU 的欄位表示當下這個程序是由哪個 CPU 處理的：\n第一個子程序結束，此時其他子程序繼續倒數中：\n第三個子程序先結束了，因為已經倒數完畢：\n最後第二個子程序結束，總共花費 9 秒：\n這邊的例子及命令的量都舉得很少，建議可以自己試試用 for loop 去產生大量的命令執行，不過還要考慮單核及多核的系統上處理的差異喔！ 可以參考 Concurrency 程式設計 - HackMD 。\n殭屍程序 程序被正常回收 我們先來看看有正常使用 wait 等待程序結束的狀況：\n1 2 # use wait time -p sh zombie.sh 命令執行中，echo 先將所有已產生程序的 PID 顯示出來，觀察以下結果 :\n每個程序的 PPID(父程序) 是誰，父 產生(→) 子 container → shell(ash) shell(ash) → time -p sh zombie.sh time -p sh zombie.sh → sh zombie.sh sh zombie.sh → sleep time -p sh zombie.sh 程序在前景執行並等待中 命令結束，所有結束的子程序都被其父程序回收，程序執行時間共約 10 秒(並發執行)：\n程序結束後未被父程序回收 再來試試不使用 wait 時，程序執行完的狀況：\n1 2 # not use wait time -p sh zombie.sh 命令執行後馬上結束，與前面的狀況有些不同：\n程序執行時間約 0.01 秒，這邊的執行時間只包含 time -p sh zombie.sh 及 sh zombie.sh 程序 每個 sleep 程序其 PPID 為 1，而這個 PID 為 1 的程序是 container 建立後產生的第一個程序，也就是最前面 docker run 時的 command 所產生的 程序結束後，其父行程沒有回收子程序，子程序變成 殭屍程序：\n那麼為什麼沒用 wait 就會讓程序變成由 PID 1 的程序來產生呢？\n我們從 wait 的 manual page 中可以得知 :\nIf a parent process terminates, then its \u0026ldquo;zombie\u0026rdquo; children (if any) are adopted by init(1), (or by the nearest \u0026ldquo;subreaper\u0026rdquo; process as defined through the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation); init(1) automatically performs a wait to remove the zombies.\n喔～由於未使用 wait 去等待 zombie.sh 產生的背景程序執行完畢，所以執行 zombie.sh 的當下程序就結束了，產生出來的子程序找不到爹，最後就被隔壁老王 init(1) 收養了(X，而這個程序在這個實驗中是由 docker run 的 command - ash 所產生的，最後可以透過以下命令去進入 container 中 PID 1 的程序：\n1 2 3 4 # 退出目前的 shell exit # 進入 sudo docker attach busybox 然後按個 enter，殭屍程序就會被回收了 。\n結果比較 有 wait 沒 wait 由其父程序進行等待並回收 由 PID 1 的程序 init(1) 接收子程序，並自動加入 wait 去結束殭屍程序 老爹給你靠 老爹跑路，隔壁老王好心收養 總結 原本只是要紀錄怎麼樣同時下命令，結果想要弄個模擬實驗就會挖更多坑，不過也算比以前更深入一點點探討運作過程中的原理，速速妹！ 參考資料 Symmetric Multi-Processing - Linux kernel concurrency sources busybox - procps/top.c Linux 中 Sleep 和 Wait 命令的使用方式 LINUX 學習日誌 - 把命令放到背景執行 Background, zombie, daemon and without ctty - are these concepts connected? How do you run multiple programs in parallel from a bash script? time(1) — Linux manual page wait(2) — Linux manual page docker attach Concurrency 程式設計 - HackMD ","date":"2022-10-16T19:56:56.431Z","permalink":"https://blog.zerolr.net/p/2022/10/16/concurrency-on-sh/","title":"【Linux】Concurrency on sh"},{"content":" Blog 搬家完後，需要重新配置 Netlify CMS 所需的檔案才能啟用，之前的 Blog 是用 Jekyll 生成的，與現在 Hugo 參數配置的部分相似，不過 Hugo 的檔案結構與 Jekyll 還是有些許不同，這篇會記錄我調整了哪些參數，建立新分支導入 CMS 功能部署測試，最後透過 CMS 建立文章後的 markdown 會長什麼樣子。\n2022-09-06 Debug： 文章中使用 cms 這個名稱作為測試功能分支，會導致 Netlify CMS 在更新 repo 時出錯，請使用 cms 以外的名稱，詳細參考：https://github.com/netlify/netlify-cms/issues/3065\nNetlify 網站建立 使用此功能前需至 Netlify 建立一個網站，參考我之前的文章 Netlify CMS 導入 GitHub Pages 記錄 。\nConfig 配置比較 更詳細的配置可以參考 Configuration Options\n之前在 Jekyll 上使用的 config 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 backend: name: github repo: zerolr/zerolr.github.io branch: main site_domain: musing-swanson-deda90.netlify.com publish_mode: editorial_workflow media_folder: \u0026#34;images/uploads\u0026#34; collections: - name: \u0026#34;blog\u0026#34; # Used in routes, e.g., /admin/collections/blog label: \u0026#34;Blog\u0026#34; # Used in the UI folder: \u0026#34;_posts/\u0026#34; # The path to the folder where the documents are stored create: true # Allow users to create new documents in this collection slug: \u0026#34;{{year}}-{{month}}-{{day}}-{{slug}}\u0026#34; # Filename template, e.g., YYYY-MM-DD-title.md fields: # The fields for each document, usually in front matter - { label: \u0026#34;Title\u0026#34;, name: \u0026#34;title\u0026#34;, widget: \u0026#34;string\u0026#34; } - { label: \u0026#34;Publish Date\u0026#34;, name: \u0026#34;date\u0026#34;, widget: \u0026#34;datetime\u0026#34; } - { label: \u0026#34;Categories\u0026#34;, name: \u0026#34;categories\u0026#34;, widget: \u0026#34;list\u0026#34; } - { label: \u0026#34;Tags\u0026#34;, name: \u0026#34;tags\u0026#34;, widget: \u0026#34;list\u0026#34; } - { label: \u0026#34;Body\u0026#34;, name: \u0026#34;body\u0026#34;, widget: \u0026#34;markdown\u0026#34; } 現在 Hugo 上使用的 config 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 backend: name: github repo: zerolr/zerolr.github.io branch: master # Branch to update (optional; defaults to master) site_domain: musing-swanson-deda90.netlify.com media_folder: static/assets/images public_folder: assets/images publish_mode: editorial_workflow collections: - name: \u0026#34;blog\u0026#34; label: \u0026#34;Blog\u0026#34; folder: \u0026#34;content/post\u0026#34; create: true slug: \u0026#34;{{year}}-{{month}}-{{day}}-{{slug}}\u0026#34; editor: preview: false fields: - { label: \u0026#34;Title\u0026#34;, name: \u0026#34;title\u0026#34;, widget: \u0026#34;string\u0026#34; } - { label: \u0026#34;Slug\u0026#34;, name: \u0026#34;slug\u0026#34;, widget: \u0026#34;string\u0026#34; } - { label: \u0026#34;Description\u0026#34;, name: \u0026#34;description\u0026#34;, widget: \u0026#34;string\u0026#34; } - { label: \u0026#34;Cover\u0026#34;, name: \u0026#34;image\u0026#34;, widget: \u0026#34;string\u0026#34; } - { label: \u0026#34;Categories\u0026#34;, name: \u0026#34;categories\u0026#34;, widget: \u0026#34;list\u0026#34;, summary: \u0026#34;{{fields.category}}\u0026#34;, field: { label: \u0026#34;Category\u0026#34;, name: \u0026#34;category\u0026#34;, widget: \u0026#34;string\u0026#34; }, } - { label: \u0026#34;Tags\u0026#34;, name: \u0026#34;tags\u0026#34;, widget: \u0026#34;list\u0026#34;, summary: \u0026#34;{{fields.tag}}\u0026#34;, field: { label: \u0026#34;Tag\u0026#34;, name: \u0026#34;tag\u0026#34;, widget: \u0026#34;string\u0026#34; }, } - { label: \u0026#34;Publish Date\u0026#34;, name: \u0026#34;date\u0026#34;, widget: \u0026#34;datetime\u0026#34; } - { label: \u0026#34;Body\u0026#34;, name: \u0026#34;body\u0026#34;, widget: \u0026#34;markdown\u0026#34; } 主要的配置簡介 repo: blog 的 repo 名稱\nbranch: 透過 CMS 修改的部分會更新至這個分支中\nsite_domain: 填入在 Netlify 上建立網站的 domain\nmedia_folder: 在 CMS 中上傳的圖片存放資料夾路徑\npublic_folder: 部署後文章存取資源的資料夾路徑\npublish_mode: 文章的發布模式，有分一般及暫存模式\ncollections: 可以定義多種文章配置，例：tech-artcle, life-article\nname: 文章的類型名稱 label: 文章配置名稱，僅影響顯示文字 folder: 文章資料夾路徑 create: 新增文章功能 slug: 自動產生的文章檔案名稱，例：2022-09-04-new-post editor(preview): 預覽文章功能 fields: 依據底下的配置在檔案中產生對應的欄位 若是使用 VSCode 編輯，可以將滑鼠移至參數上，會顯示詳細說明\n我主要改了什麼？ media_folder: Hugo 在 build 後會將 static 中的檔案放在 root 下， 而 CMS 上傳的圖片會存在這個路徑，如此 build 後的資源才可被網頁存取 public_folder: 承上，文章從此路徑存取圖片 fields: 原本照之前的配置時，會有 Tags 與 Categories 只能輸入一個字串的問題，且字串中不能有空格，後來在這篇 issue中找到方法處理，利用 summary 來組合不同參數，結果如下圖 建立新分支加入 Netlify CMS 部署測試 在加入 Netlify CMS 的檔案前，先分別建立給 master 及 cms 分支使用的 workflows。\n觀察模板提供的 deploy.yml 這段表示當 repo 被 push 或 pull_request 到 master 分支時，會執行這個 yml 檔的部署工作。\n1 2 3 4 5 on: push: branches: [master] pull_request: branches: [master] 中間還有安裝套件、暫存資源、建置靜態檔案等等流程，直接拉到最下面 Deploy 的地方，這邊表示部署 gh-pages 中的檔案。\n1 2 3 4 5 6 7 - name: Deploy 🚀 uses: JamesIves/github-pages-deploy-action@4.1.4 with: branch: gh-pages folder: public clean: true single-commit: true 建立給新分支部署用的 deploy.yml 將原本的 deploy.yml 改為 deploy_master.yml,，並建立一個 deploy_cms.yml，修改觸發部署的分支為 cms，以及部署分支改為 gh-pages-feature-test。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 # deploy_cms.yml name: Deploy to Github Pages - Feture test on: push: branches: [cms] pull_request: branches: [cms] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Cache Hugo resources uses: actions/cache@v2 env: cache-name: cache-hugo-resources with: path: resources key: ${{ env.cache-name }} - uses: actions/setup-go@v2 with: go-version: \u0026#34;^1.17.0\u0026#34; - run: go version - name: Cache Go Modules uses: actions/cache@v2 with: path: | ~/.cache/go-build ~/go/pkg/mod key: ${{ runner.os }}-go-${{ hashFiles(\u0026#39;**/go.sum\u0026#39;) }} restore-keys: | ${{ runner.os }}-go- - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build run: hugo --minify --gc - name: Deploy 🚀 uses: JamesIves/github-pages-deploy-action@4.1.4 with: branch: gh-pages-feature-test folder: public clean: true single-commit: true 修改完後在 master 分支加入紀錄。\n1 2 git add . git commit -m \u0026#34;feat: update workflow for master branch, add new workflow for cms branch\u0026#34; 此時這個版本的紀錄會留在已建立好 master 與 cms 分支用的 workflows 上，下一步再將 Netlify CMS 所需的檔案加入。\n建立 cms 分支並將 Netlify CMS 檔案加入 首先建立並切換至 cms 分支。\n1 git checkout -b cms 將 Netlify CMS 所需的檔案放在 static 目錄底下，後面 build 後才能讓 admin 輸出在根目錄中。\n1 root - static - admin - config.yml - index.html 建立 commit 記錄本次修改。\n1 2 git add . git commit -m \u0026#34;feat: add netlify cms\u0026#34; 此時 cms 分支會領先 master 分支一個 commit，可以參考下面的補充，接下來要準備部署上去。\n補充： git branch 分支建立 點擊展開 這邊用範例來解釋分支，新開資料夾加入一個 blog.txt 檔案，並建立 git 環境加入 commit。\n1 2 3 4 5 6 mkdir git-branch-test cd git-branch-test git init echo \u0026#34;This is blog file\u0026#34; \u0026gt;\u0026gt; blog.txt git add . git commit -m \u0026#34;initial commit\u0026#34; 使用 git log 查看狀態，目前有一個 commit ，HEAD 表示目前所在的 commit，箭頭指向的位置表示 commit 所在的分支。\n1 2 git log --oneline d5bf87b (HEAD -\u0026gt; master) initial commit 建立分支並切換過去，使用以下指令達成，加上 -b 可以新增分支同時切換過去。\n1 git checkout -b cms 檢查所在分支用 git branch 指令，*符號位置表示所在分支。\n1 2 3 git branch master *cms 加入 config.yml 檔案並建立 commit 後，使用 git log 查看狀態，由於是基於此時的 master 分支上建立分支，在 cms 分支中會有 master 分支的 commit，且比 master 分支領先一個 commit ，意思就是比 master 分支領先一筆修改紀錄。\n1 2 3 4 5 6 echo \u0026#34;This is config file\u0026#34; \u0026gt;\u0026gt; config.yml git add . git commit -m \u0026#34;feat: add config.yml\u0026#34; git log --oneline 09103bc (HEAD -\u0026gt; cms) feat: add config.yml d5bf87b (master) initial commit 我們可以切回去 master 分支查看 git log，剛才前面那個 commit 及 config.yml 不見了！ 因為剛才是在 cms 分支中建立 commit ，新增 config.yml 這筆紀錄只有在 cms 的分支中才能看到，所以可以依據想加入的功能開對應的分支。\n1 2 3 4 5 git checkout master Switched to branch \u0026#39;master\u0026#39; git log --oneline d5bf87b (HEAD -\u0026gt; master) initial commit 可以把 branch 想像成是資料夾，開分支就是從 master 資料夾複製一份並重新命名成 cms，commit 就是對資料夾內的內容做編輯，以範例來說最後 master 有一份檔案，而 cms 則有兩份檔案囉！\n部署測試版網站 將程式 push 至 遠端 repo 的 cms 分支上，push 遠端不存在的分支時 GitHub 會幫我們建立，且因 cms 分支被 push 還會觸發 deploy_cms.yml 的 workflow。\n1 git push origin cms push 完後到網頁查看 GitHub repo，左邊清單可以看到目前有的分支，可以比較 master 與 cms 中的檔案是否如預期不同。\n至 repo 中的 Actions 查看結果，可以看到執行工作流程的檔案及名稱，以及底下完成過的工作。\n待 workflow 工作完成後，至 repo → Settings → Pages 底下，在 Branch 的欄位中選擇你要部署網站的分支，這邊選擇由 deploy_cms.yml 所產生的 gh-pages-feature-test 分支，按下 Save 後就會開始部署。\n部署中的過程一樣可以在 Actions 中查看，可以點進去看更詳細的過程，失敗的錯誤訊息在這邊都可以查得到。\n成功部署後開啟網站進入 CMS 管理畫面，登入已授權的 GitHub 帳號後就可以開始建立文章囉！\n合併新功能至 master 分支 新增的功能測試完成後，就可以合併回 master 分支進行正式網站的部署，在 repo 可以看到提示你合併分支的訊息。\n點擊 Compare \u0026amp; pull request ，這邊會檢查有無衝突，往下拉可以看到從 cms 分支 合併回 master 分支時的內容差異，確認都沒問題後填寫 commit 訊息，按下 Create pull request 就成功發送合併請求。\n這時在 Pull requests 中就有個合併請求產生，合併前可以檢查 Files changed 中的資訊，確定變動的內容都沒有問題後就可以合併了。\n合併之後記得回到 Settings → Pages 中將部署的 Branch 更改為 gh-pages 作為正式部署的網站。\n使用 CMS 建立文章 這邊建立文章填入內容，注意 SLUG 欄位會變成文章的網站路徑，建議以英文加分隔符號的格式命名，讓人看網址就知道主題是什麼，COVER 欄位為文章預覽圖，填絕對路徑會從部署的檔案中查找，也可使用圖片 URL。\n檢查完沒問題後就可以發布文章囉！\n透過 CMS 發佈的文章檔案，上方的欄位配置就是依照編輯器中的內容產生的！\n若有啟用 publish_mode: editorial_workflow ，文章會分成三種階段狀態儲存，分別為 Draft, In Review, Ready，一開始儲存會在 Draft 狀態，只有將狀態切換為 Ready 才能 publish 至網站中。\n當文章不斷修改儲存時，網站會先建立暫存的 commit ，每一次的 Save 都會建立一次，直到 publish 後才會一併 push 至 repo 中，並且會自動建立 pull request 去合併中間產生的 commit 再 merge 回 repo 中。\n安全問題 就跟使用其他需登入的網站服務一樣，有以下幾個點需注意：\n除非是自己的電腦，在其他電腦上請開無痕視窗使用。 使用時會需要登入 GitHub，在 CMS 這邊登入完後會發現 GitHub 那邊也登入了，所以請記得離開或不用時登出。 使用未註冊 provider 的 GitHub 帳號登入時會被擋下來，若要增加共同編輯的帳號，需在其帳號下建立 OAuth APP，並且將 Client ID 及 Secret 提供給管理員去 provider 。 總結 重新再跑過一遍安裝流程後對配置又更熟悉了一點，也發現 CMS 連側邊欄位那些頁面也能編輯，之後會再更新上去。同時也是第一次嘗試另外開分支加入新功能測試部署，在嘗試的過程中一直在想這種做法是否合適，若對本篇做法有任何看法非常歡迎留言指教！\n參考資料 Netlify CMS - Hugo List widget form input prevents whitespace and commas Configuration Options 建立分支【教學 1 使用分支】 | 連猴子都能懂的 Git 入門指南 | 貝格樂（Backlog） ","date":"2022-09-05T14:30:19.036Z","image":"https://blog.zerolr.net/post/images/cover/hugo-wide.jpeg","permalink":"https://blog.zerolr.net/p/2022/09/05/netlify-cms-import-hugo/","title":"【Hugo】Netlify CMS 導入 Hugo 網站紀錄"},{"content":" 用了一陣子簡約風的 jekyll 後，覺得還是太空了，要找相關主題的文章還要找好久，沒有預覽圖可以快速檢視想看的文章，加上之前就很想用 Hugo 來部署個人 blog 了，這次買了個 Domain 後就想來重新裝潢一下 blog。 Hugo Themes 中真的一堆大神做超好看的模板 RRR，這篇紀錄如何使用 Hugo Themes 中的 Stack 模板，觀察其中檔案以及部分設定修改，至於 CMS 的部分可以參考之前寫的 Netlify CMS 導入 GitHub Pages 記錄，不過在 Hugo 中導入的流程有些不同，就留到下一篇紀錄囉！\n安裝 Hugo 安裝 Hugo 的部分就不說了，都在官方文件中！\n從作者提供的 Template 建立 repo 使用 hugo-theme-stack-starter 建立 repo 後如下，作者: Jimmy Cai。\n觀察檔案與調整 .github/workflows/deploy.yml 將 repo clone 到電腦中，可以看到在 .github/workflows 中，作者已經寫好部署網站的deploy.yml檔了，在電腦中測試完用 git push 後就會幫你部署至 gh-pages 的分支囉！\n當 push 新的 commit 上去時，GitHub Actions 會根據 workflows 中的 yml 進行一連串的動作將網站部署完成，想了解如何做到的可以參考 GitHub Actions 。\n.github/workflows/update-theme.yml 在 .github/workflows 中還可以看到另一個檔案 update-theme.yml ，看了內容後個人覺得是用來自動更新模板檔的流程，我自己不需要就刪掉了。\n.github/.devcontainer 在 .devcontainer 中還有提供 Dockerfile 能夠將網站包裝成 Docker Image，對於想部署在不同平台上的人來說很方便，可以先留著日用有機會試試。\nconfig/_default 網站的標題、外觀主題、語言、頭像、連結…基本上都由這邊的檔案進行設定，參考 Configure Hugo 或是網路上有很多文章解說如何設定喔！\ncontent/post 模板預設已經有一篇 hello-world 的文章，可以參考內文格式撰寫文章，這邊我就把之前寫的搬過來，也能加上標題圖片。\nLocal 端執行/建置網站 在專案根目錄中執行以下指令開啟網站檢視。\n1 hugo server 在專案根目錄中執行以下指令建置網站，靜態檔案輸出在 public 資料夾中，指令部分參考 hugo commands 。\n1 hugo --minify --gc 部署至 GitHub pages 可以直接把剛才 build 出來的靜態檔直接推上去，不過這邊就利用 GitHub Actions 來完成建置及部署的動作。\n總結 直接搬別人提供的東西來用是很方便，但對於 Hugo 本身是如何藉由模板的方式來產生網頁不熟悉的話，往後要修改就不容易了，如果想更客製化自己的 blog ，最好還是把官方文件看熟才是王道！\n參考資源 Hugo Themes Theme - Stack ","date":"2022-09-03T00:00:00Z","image":"https://blog.zerolr.net/post/images/cover/hugo-wide.jpeg","permalink":"https://blog.zerolr.net/p/2022/09/03/hugo-new-theme/","title":"【Hugo】又…又改主題!!!"},{"content":" 原本部落格文章的新增或更新需要修改檔案，就在想有沒有像是 Wordpress 那種有後台能夠直接新增文章的功能可以使用，翻一下 google 就找到一個蠻多人用的 Netlify CMS，嘗試導入這個部落格後覺得真的很方便。能夠在原本的網站中新增一個控制台管理文章，文章的新增/修改/刪除只要一鍵就幫你完成 commit, publish, deploy 這些步驟，雖然原理還沒有很深入了解，但不用每次開 VSCode 起來改檔案新增文章就是舒服啦(已知用火)！\n導入流程 建立 GitHub OAuth APP 前往 GitHub Dev Settings 建立 GitHub OAuth APP，使用這個 CMS 時會需要登入自己的 GitHub。\nAuthorization callback URL 填入https://api.netlify.com/auth/done，透過 GitHub OAuth APP 登入時取得的 Access token 會再拿去 Authorization callback URL 這個 API(Serve-to-server)驗證。\nNetlify 註冊 Provider 前往 Netlify 建立一個網站，repo 任意選擇即可，網站並不會部署在選擇的 repo 上。\n前往 Site settings ，記下這個網站的名稱後面會用到，格式應該長得像 octopus-cat-123456。\n側邊欄選擇 Domain Management ，新增 Custom domains 為 you.github.io 。\n側邊欄選擇 Access control ，選擇 OAuth ，點擊 Install provider。\nProvider 選擇 GitHub，輸入從 GitHub OAuth APP 中的 Client ID 與 Client Secret。\n在網站中啟用 Netlify CMS 管理頁面 在自己部落格的根資料夾中新增 admin 資料夾，建立 index.html 與 config.yml，內容如下，在 config.yml 中記得將 repo 與 site_domain 修改成自己的部落格與剛剛記下的 Netlify 網站名稱，以及要注意自己部落格的 branch 是否跟 config 中的相同。\nadmin/index.html 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Content Manager\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- Include the script that builds the page and powers Netlify CMS --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/netlify-cms@^2.10.187/dist/netlify-cms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; admin/config.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 backend: name: github repo: you/you.github.io branch: master site_domain: octopus-cat-123456.netlify.com media_folder: \u0026#34;images/uploads\u0026#34; collections: - name: \u0026#34;blog\u0026#34; # Used in routes, e.g., /admin/collections/blog label: \u0026#34;Blog\u0026#34; # Used in the UI folder: \u0026#34;_posts/\u0026#34; # The path to the folder where the documents are stored create: true # Allow users to create new documents in this collection slug: \u0026#34;{{year}}-{{month}}-{{day}}-{{slug}}\u0026#34; # Filename template, e.g., YYYY-MM-DD-title.md fields: # The fields for each document, usually in front matter - { label: \u0026#34;Title\u0026#34;, name: \u0026#34;title\u0026#34;, widget: \u0026#34;string\u0026#34; } - { label: \u0026#34;Publish Date\u0026#34;, name: \u0026#34;date\u0026#34;, widget: \u0026#34;datetime\u0026#34; } - { label: \u0026#34;Tags\u0026#34;, name: \u0026#34;tags\u0026#34;, widget: \u0026#34;list\u0026#34; } - { label: \u0026#34;Body\u0026#34;, name: \u0026#34;body\u0026#34;, widget: \u0026#34;markdown\u0026#34; } 推送上去 GitHub 後，就可開啟 https://you.github.io/admin 進入 CMS 管理系統囉！\n補充 如果想要暫時保存新文章或修改，可以在 config.yml 加上下方的參數 ，就可以開啟暫存相關功能了，還分成 Draft, In review, Ready 三種階段來管理各個文章進度喔！\n1 publish_mode: editorial_workflow 總結 實際用過後有些點需要注意，預設文章連結會用 titile 作為 path，若超過 50 個字就會報錯(忘記哪邊的限制)，文字在 url 中會被轉換為 base64 格式，很容易就會超過上限，另一個問題是用 CMS 發布文章後，bot 會幫你 merge 新的 post 到 repo 中，若想修改檔案記得要先 git pull 同步。\n參考資料 Just 3 Steps: Adding Netlify CMS to Existing GitHub Pages Site Within 10 Minutes NetlifyCMS - Overview NetlifyCMS - Publish Mode What is \u0026ldquo;User authorization callback URL\u0026rdquo; for? Authorizing OAuth Apps - GitHub Docs ","date":"2022-03-05T01:17:30.996Z","image":"https://blog.zerolr.net/post/images/cover/netlify-cms.png","permalink":"https://blog.zerolr.net/p/2022/03/05/netlify-cms-import-github-pages/","title":"Netlify CMS 導入 GitHub Pages 記錄"},{"content":" 在 jekyll-next-theme 中已經將 gitalk 功能整合好了，但是在出現 gitalk 留言功能的文章以外的頁面，會出現一個找不到 gitalk-container 這個 element 的錯誤訊息，回去看程式碼發現 gitalk 會在所有頁面啟用，試著將 gitalk 限制在 post 類型(文章)的頁面中啟用就成功了。\n解決方法 開啟 \u0026lt;your_blog\u0026gt;/_includes/_third_party/comments/gitalk.html\n將原本的 site.gitalk.enable 判斷 加上與 page.id 做 and 運算，只有當進入文章時才啟用 gitalk\n1 2 3 4 \u0026lt;!-- old --\u0026gt; if site.gitalk.enable \u0026lt;!-- new --\u0026gt; if site.gitalk.enable and page.id 總結 總覺得這解決方法不怎麼優，但對 jekyll 也不熟就湊合著用了。\n參考資料 How can jekyll judge whether it is a page or a post? ","date":"2021-12-22T00:00:00Z","permalink":"https://blog.zerolr.net/p/2021/12/22/jekyll-gitalk-issue/","title":"【Jekyll】解決gitalk啟用後錯誤訊息問題"},{"content":" 由於工作上的需求入手了 MacBook Air M1，順便提早熟悉在 ARM 架構上開發會遇到的問題。 重生後的第一篇就來記錄一下這個 blog 架設中所遇到的問題囉！\n系統環境 MacOS: Monterey\n版本: 12.1\n架構: aarch64\n使用軟體/工具 ruby 2.6.8 jekyll 3.26.0 bundler 1.17.2 架設流程 準備好自己的 Github 帳號。 建立 github page 與挑選自己喜歡的 jekyll 主題套用，參考的文章放在底部的參考資料中囉。 嘗試處理 jekyll 安裝問題 jekyll 安裝失敗 首先用 gem 安裝 jekyll，結果出現以下錯誤訊息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ sudo gem install -n /usr/local/bin jekyll --user-install Successfully installed jekyll-4.2.1 Parsing documentation for jekyll-4.2.1 Before reporting this, could you check that the file you\u0026#39;re documenting has proper syntax: /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/bin/ruby -c lib/jekyll/commands/doctor.rb RDoc is not a full Ruby parser and will fail when fed invalid ruby programs. The internal error was: (NoMethodError) undefined method `[]\u0026#39; for nil:NilClass ERROR: While executing gem ... (NoMethodError) undefined method `[]\u0026#39; for nil:NilClass jekyll 安裝問題解決 更新 gem 就可以正確安裝了：\n1 $ sudo gem update 再次安裝：\n1 2 3 4 5 6 $ sudo gem install -n /usr/local/bin jekyll --user-install Successfully installed jekyll-4.2.1 Parsing documentation for jekyll-4.2.1 Installing ri documentation for jekyll-4.2.1 Done installing documentation for jekyll after 0 seconds 1 gem installed 但執行 sudo jekyll new blog 時卻噴了一大串的錯誤，目前還不知道怎麼解決，所以改成直接 clone jekyll-theme-next 提供的範例檔來做。\n改從範例檔進行安裝 bundle exec jekyll server 失敗 首先照官方的步驟進行安裝，在使用bundle install 前要先 update：\n1 $ bundle update 將套件都裝好後，嘗試啟動失敗：\n1 2 3 4 5 6 $ bundle exec jekyll server /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/forwardable.rb:116: warning: already initialized constant Forwardable::VERSION ... Configuration file: /Users/ceyanglab/Documents/github/jekyll-theme-next/_config.yml Dependency Error: Yikes! It looks like you don\u0026#39;t have jemoji or one of its dependencies installed. In order to use Jekyll as currently configured, you\u0026#39;ll need to install this gem. The full error message from Ruby is: \u0026#39;cannot load such file -- nokogiri/nokogiri\u0026#39; If you run into trouble, you can find helpful resources at https://jekyllrb.com/help/! jekyll 3.9.0 | Error: jemoji 一開始以為是 jemoji 的問題，移除後連啟動都無法，只好再裝回來：\n1 2 3 $ bundle exec jekyll server Could not find jemoji-0.12.0 in any of the sources Run `bundle install` to install missing gems. 再次搜尋資料，查到有可能重複安裝多個 jekyll 導致啟動失敗，那就刪掉多的吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ sudo gem uninstall jekyll You have requested to uninstall the gem: jekyll-3.9.0 github-pages-222 depends on jekyll (= 3.9.0) jekyll-default-layout-0.1.4 depends on jekyll (~\u0026gt; 3.0) jekyll-swiss-1.0.0 depends on jekyll (~\u0026gt; 3.2, development) If you remove this gem, these dependencies will not be met. Continue with Uninstall? [yN] y Successfully uninstalled jekyll-3.9.0 Select gem to uninstall: 1. jekyll-4.2.1 2. jekyll-4.2.1 3. All versions \u0026gt; 2 You have requested to uninstall the gem: jekyll-4.2.1 再次嘗試啟動依然報同樣的錯 Orz，仔細觀察錯誤訊息發現關鍵字：\n1 The full error message from Ruby is: \u0026#39;cannot load such file -- nokogiri/nokogiri\u0026#39; 套件問題處理 嗯好應該是 nokogiri 這個套件的問題，開 gem 的清單看一下：\n1 2 3 4 $ gem list ... nokogiri (1.12.5 arm64-darwin x86_64-darwin, 1.10.1) ... 同時有 arm 跟 x86 版本的套件存在，刪掉其他只留 arm 的試試：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ sudo gem uninstall nokogiri Select gem to uninstall: 1. nokogiri-1.12.5-x86_64-darwin 2. nokogiri-1.12.5-x86_64-darwin 3. nokogiri-1.12.5-arm64-darwin 4. All versions \u0026gt; 1 Successfully uninstalled nokogiri-1.12.5-x86_64-darwin Select gem to uninstall: 1. nokogiri-1.12.5-x86_64-darwin 2. nokogiri-1.12.5-arm64-darwin 3. All versions \u0026gt; 1 Successfully uninstalled nokogiri-1.12.5-x86_64-darwin 成功啟動網站 果然是 nokogiri 套件的問題，可以正常啟動了：\n1 2 3 4 5 6 7 8 9 10 11 12 $ bundle exec jekyll server ... Configuration file: /Users/ceyanglab/Documents/github/jekyll-theme-next/_config.yml Source: /Users/ceyanglab/Documents/github/jekyll-theme-next Destination: /Users/ceyanglab/Documents/github/jekyll-theme-next/_site Incremental build: disabled. Enable with --incremental Generating... Jekyll Feed: Generating feed for posts done in 1.813 seconds. Auto-regeneration: enabled for \u0026#39;/Users/ceyanglab/Documents/github/jekyll-theme-next\u0026#39; Server address: http://127.0.0.1:4000 Server running... press ctrl-c to stop. 總結 遇到問題時先好好看錯誤訊息，才不會答案擺在眼前還到處盲試。\n參考資料 從零開始: 用 github pages 上傳靜態網站 - sexyoung NexT 使用文檔 ","date":"2021-12-20T18:00:00Z","permalink":"https://blog.zerolr.net/p/2021/12/20/jekyll-mac-m1-issue/","title":"【Jekyll】Mac M1 安裝 Jekyll 踩雷記錄"}]